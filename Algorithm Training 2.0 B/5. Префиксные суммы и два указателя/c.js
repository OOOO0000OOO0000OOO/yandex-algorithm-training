/**
 * @param { Number[] } array 
 * @returns { Number[] }
 */

const sortAndEnum = (array) =>
  array
    .map((value, index) => [value, index])
    .sort(([a], [b]) => a - b);

/**
 * "C. Каждому по компьютеру"
 * https://contest.yandex.ru/contest/29075/problems/C/
 * 
 * В новом учебном году на занятия в компьютерные классы Дворца Творчества Юных пришли
 * учащиеся, которые были разбиты на N групп. В i-й группе оказалось Xi человек. Тут же перед
 * директором встала серьезная проблема: как распределить группы по аудиториям. Во
 * дворце имеется M ≥ N аудиторий, в j-й аудитории имеется Yj компьютеров. Для занятий
 * необходимо, чтобы у каждого учащегося был компьютер и еще один компьютер был у
 * преподавателя. Переносить компьютеры из одной аудитории в другую запрещается.
 * Помогите директору!
 * Напишите программу, которая найдет, какое максимальное количество групп удастся
 * одновременно распределить по аудиториям, чтобы всем учащимся в каждой группе хватило
 * компьютеров, и при этом остался бы еще хотя бы один для учителя.
 * 
 * @param { Number[] } groups группы (1 ≤ Xi ≤ 1000 для всех 1 ≤ i ≤ N)
 * @param { Number } n (1 ≤ N ≤ M ≤ 1000)
 * @param { Number[] } rooms компьютеры в аудиториях (1 ≤ Yi ≤ 1000 для всех 1 ≤ i ≤ M)
 * @param { Number } m (1 ≤ N ≤ M ≤ 1000)
 * 
 * @returns { String }
 * Выведите на первой строке число P - количество групп, которые удастся распределить по
 * аудиториям. На второй строке выведите распределение групп по аудиториям – N чисел, i-е
 * число должно соответствовать номеру аудитории, в которой должна заниматься i-я группа.
 * (Нумерация как групп, так и аудиторий, начинается с 1). Если i-я группа осталась без
 * аудитории, i-е число должно быть равно 0. Если допустимых распределений несколько,
 * выведите любое из них.
 */

const findGroupsDistribution = (groups, n, rooms, m) => {
  const sortedGroups = sortAndEnum(groups);
  const sortedRooms = sortAndEnum(rooms);

  const answer = new Array(n).fill(0);

  let right = 0;
  let count = 0;

  for (const [left, group] of sortedGroups) {
    while (right < m && sortedRooms[right][0] < left + 1) {
      right += 1;
    }

    if (right === m) break;

    answer[group] = sortedRooms[right][1] + 1;

    right += 1;
    count += 1;
  }

  return `${count}\n${answer.join(' ')}`;
};

export default findGroupsDistribution;
